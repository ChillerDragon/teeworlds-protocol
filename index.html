<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="css/style.css">
    <title>Teeworlds Protocol</title>
</head>
<body>
    <div class="content">
        <h2>The teeworlds 0.7 network protocol</h2>
        <p>
            This is an effort to document the network protcol of the game <a href="https://teeworlds.com">teeworlds</a>.
            Only looking at the <a href="https://teeworlds.com/?page=downloads&id=14786">0.7.x</a> implemenations. The <a href="https://teeworlds.com/?page=downloads&id=5063">0.5.x</a> and <a href="https://github.com/teeworlds/teeworlds/tree/0.6">0.6.x</a> implemenations are slightly different and incompatible.

            All packets are prefixed with a <code>[SOURCE->DESTINATION]</code> indicating who is sending the packet to who.
            The packets are listed in the order they are supposed to be send when a client connects to a server.
            <br><br>
            The packet content is displayed as space seperated hexadecimal encoded bytes.
            <br>
            So <code class="code-inline">01</code> means that the bits <code class="code-inline">00000001</code> are sent via the network.
            <br>
            And <code class="code-inline">FF</code> means that the bits <code class="code-inline">11111111</code> are sent via the network.
            <br>
            <br>
            This matches the output of the network dumping tool <code class="code-inline">tcpdump</code>.
            If you have <a href="https://www.tcpdump.org/">tcpdump</a> installed on your system you can print teeworlds traffic using this command:
            <pre class="code-snippet">
                <code>
    tcpdump -nX -i lo "port 8303"
                </code>
            </pre>
            Assuming your loopback network interface is called lo and you have a teeworlds server running on its default port 8303.
        </p>

        <hr>
        <h3>[CLIENT->SERVER] Hello server this is my token</h3>
        <p>
            The first packet that is being sent is from the client to the server.
            The only data that is being transmitted is the security token from the client.
            The packet header contains <code>FF FF FF FF</code> as placeholder for the server token.
            Since the client does not know the server token yet.

            At the end this packet contains 501 nullbytes to prohibit reflection attacks.
            Those nullbytes are not shown below.
        </p>
        <pre class="code-snippet">
            <code>
    &lt;04  00  00  <span class="token">FF  FF  FF  FF</span>&gt;&lt;05&gt;&lt;<span class="token">51  3B  59  46</span>&gt;
     ^                           ^   ^
size=7 flags=1                   |   client token
                             NET_CTRLMSG_TOKEN
            </code>
        </pre>

        <hr>
        <h3>[SERVER->CLIENT] Hello client this my token</h3>
        <p>
            As a response to the clients hello the server answers with its token.
            So after the packet header containing the clients token. The only data that is being sent.
            Is the servers security token.
        </p>
        <pre class="code-snippet">
            <code>
    &lt;04  00  00  <span class="token">51  3B  59  46</span>&gt;&lt;05&gt;&lt;<span class="token">C0  7D  1E  5E</span>&gt;
     ^           ^               ^   ^
size=7 flags=1   |               |   server token
                 |         NET_CTRLMSG_TOKEN
                client token
            </code>
        </pre>

        <hr>
        <h3>[CLIENT->SERVER] Connect</h3>
        <p>
            After server and client exchanged tokens the client will once again send its token.
            This time setting the Control Message to NET_CTRLMSG_CONNECT to initiate the connection.

            At the end this packet contains 501 nullbytes to prohibit reflection attacks.
            Those nullbytes are not shown below.
        </p>
        <pre class="code-snippet">
            <code>
    &lt;04  00  00  <span class="token">C0  7D  1E  5E</span>&gt;&lt;01&gt;&lt;<span class="token">51  3B  59  46</span>&gt;
     ^           ^               ^   ^
size=7 flags=1   |               |   client token
            server token     NET_CTRLMSG_CONNECT
            </code>
        </pre>

        <hr>
        <h3>[SERVER->CLIENT] Accept connection</h3>
        <p>
            If this packet is sent the server log will show this message.
            <br>
            <code>
                [2022-10-25 14:22:25][connection]: got connection, sending accept
            </code>
            <br>
        </p>
        <pre class="code-snippet">
            <code>
    &lt;04  00  00  <span class="token">51  3B  59  46</span>&gt;&lt;02&gt;
     ^           ^               ^
size=7 flags=1   |               |
                 |       NET_CTRLMSG_ACCEPT
            client token
            </code>
        </pre>

        <hr>
        <h3>[CLIENT->SERVER] Version and password</h3>
        <p>
            Now the client will inform the server about its version.
            This packet is defined in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L340-L353">CClient::SendInfo()</a>
            and contains the password, the network hash and the supported protocol version.
            The vanilla client always sends the password that was entered last by the user.
            No matter which server it is connecting to also if the server does not expect a password.
            This is nice since it minimizes user input even if the ip changes or multiple servers have the same password.
            But it is leaking the password you entered last to every server you connect to.
            That is why the <a href="https://ddnet.org/">ddnet</a> client decided to only send the password after user confirmation.
            <br>
            <br>
            If the server recieves this packet it will log the following line.
            <br>
            <code>
                [2022-10-25 14:22:25][connection]: connecting online
            </code>
            <br><br>
            Since the packet payload now contains uncompressed printable ASCII characters those are included below.
            You can quickly identify this packet when running <code class="code-inline">tcpdump</code> with the <code class="code-inline">-X</code>flag.
        </p>
        <pre class="code-snippet">
            <code>
    [PACKET HEADER]
    00  00  01  <span class="token">C0  7D  1E  5E</span>
                ^
            server token

    [PACKET PAYLOAD HEX]                       [PACKET PAYLOAD ASCII]
    40 28 01 03  30 2E 37 20  38 30 32 66      @(..<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L8">0.7</a> <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L7">802f</a>
    31 62 65 36  30 61 30 35  36 36 35 66      <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L7">1be60a05665f</a>
    00 6D 79 5F  70 61 73 73  77 6F 72 64      <span class="red">my_password</span>
    5F 31 32 33  00 85 1C 00                   <span class="red">_123</span>...
            </code>
        </pre>

        <hr>
        <h3>[SERVER->CLIENT] Map info</h3>
        <p>
            Now the server is informing the client about the map. This is NOT the mapfile it self. Just its metadata.
            To see what exactly is being sent checkout the code of <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L709-L719">CServer::SendMap</a>
            it boils down to this:

            <pre class="code-snippet">
                <code>
    String GetMapName()
    Int    m_CurrentMapCrc
    Int    m_CurrentMapSize
    Int    m_MapChunksPerRequest
    Int    MAP_CHUNK_SIZE
    Raw    m_CurrentMapSha256
                </code>
            </pre>

            In the ASCII representation of the packet you can spot the mapname.
            <br>
            In this case the map is called <code class="orange">skyblock</code>.

            <pre class="code-snippet">
                <code>
    [PACKET HEADER]
    00  01  01  <span class="token">51  3B  59  46</span>

    [PACKET PAYLOAD HEX]                       [PACKET PAYLOAD ASCII]
    40 34 01 05  73 6B 79 62  6C 6F 63 6B      @4..<span class="orange">skyblock</span>
    00 D8 D1 95  A0 0F A5 0E  08 A8 15 76      ...........v
    BA 3A AE 46  F3 F5 E6 31  7A 8C BD 7E      .:.F...1z..~
    A4 B2 44 C4  7E 0E FF B5  86 7F 4B E3      ..D.~.....K.
    CA E7 50 93  14 0D 88 00                   ..P....
                </code>
            </pre>
        </p>

        <hr>
        <h3>[CLIENT->SERVER] Ready</h3>
        <p>
            If the client already has the map or finished the download process it will respond with the ready packet.
            The map download packets are yet to be documented.
            <br>
            <br>
            If the server gets this packet it will print the following log line.
            <br>
            <code>
                [2022-10-25 14:22:25][server]: player is ready. ClientID=0 addr=[0:0:0:0:0:0:0:1]:61985
            </code>
        </p>
        <pre class="code-snippet">
            <code>
                &lt;00  01  <span class="token">01  C0  7D  1E  5E</span>&gt; 40  01  02  25     ....}.^@..%
                 ^           ^                   ^
        size=7 flags = 0     |         NETMSG_READY (TODO: annotate better how it turns 40 01 02 25 into 18 NETMSG_READY)
                        server token
            </code>
        </pre>
    </div>
    <footer>
        <hr>
        <div class="footer">
            <!-- Icon-link to source code on GitHub -->
            <a class="github" href="https://github.com/ChillerDragon/teeworlds-protocol" target="_blank" rel="noopener" aria-label="Source code">
                <!-- icon: https://materialdesignicons.com/icon/github -->
                <svg viewBox="0 0 24 24" class="github">
                    <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" />
                </svg>
            </a>
            <span>
                ChillerDragon - 2022
            </span>
        </div>
    </footer>
</body>
</html>

