<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="../css/style.css">
    <title>Teeworlds Protocol</title>
</head>
<body>
    <div class="header">
        <a href="../index.html">
            <img src="../img/tee.svg" alt="tee">
        </a>
        <a href="../index.html">home</a>
        <a href="fundamentals.html">fundamentals</a>
        <a href="traffic.html">traffic</a>
        <a href="snap_items.html">snap_items</a>
        <a href="system_messages.html">system_messages</a>
        <a href="game_messages.html">game_messages</a>
        <hr>
    </div>
    <div class="content">
        <h1>List of network system messages</h1>
        <p>
            There are two types of messages: system messages and game messages <br>
            This list is only covering system messages. Game messages can be found <a href="game_messages.html">here</a>. <br>
            <br>
            When the client and server exchange packets.
            An integer field which usually does not exceed one byte.
            Is indicating which type of message was sent.
            This field is called the message id.
            These message ids are defined in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/shared/protocol.h#L31-L76">
                src/engine/shared/protocol.h
            </a>
            and their payload is defined where they are sent and received.
            There can be multiple messages in so called chunks in one teeworlds packet.
            <br>
            <br>
            In the list below you will find those message.
            With their name, id and payload.
        </p>
        <hr>
        <h2 id="NETMSG_NULL"><a href="#NETMSG_NULL">NETMSG_NULL</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Message ID:</strong></th><td>0</td>
                </tr>
            </table>
            <br>
        </p>
        <hr>
        <h2 id="NETMSG_INFO"><a href="#NETMSG_INFO">NETMSG_INFO</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>1</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="ctrl_messages.html#NET_CTRLMSG_ACCEPT">NET_CTRLMSG_ACCEPT</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_net_version"><a href="#NETMSG_INFO_net_version">Net Version</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        The official name is "NetVersion" but a more fitting name in my opinion would be "Protocol Version".
                        <br>
                        The variable <code>GAME_NETVERSION</code> always expands to <code>"0.7 802f1be60a05665f"</code><br>
                        If the server gets another string it actually rejects the connection. This is what prohibits
                        0.6 clients to join 0.7 servers.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_password"><a href="#NETMSG_INFO_password">Password</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        If the config option <code>password</code> is set on the server. This password has to match to join the server.
                        The vanilla 0.7 client always sends the last used passwords to all servers no matter if they expect a password or not.
                        And servers simply ignore this field if no password is expected.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_client_version"><a href="#NETMSG_INFO_client_version">Client Version</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        Another version field which does not have to match the servers
                        version to establish a connection. The first net version field makes sure
                        that client and server use the same major protocol and are compatible.
                        This "Client Version" field then informs the server about the clients minor version.
                        The server can use it to activate some non protocol breaking features
                        that were introduced in minor releases.
                    </td>
                </tr>
            </table>
            <br>
            Sent by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L340-L353">
                CClient::SendInfo()
            </a>
            <pre class="code-snippet">
                <code>
    void CClient::SendInfo()
    {
        // restore password of favorite if possible
        const char *pPassword = m_ServerBrowser.GetFavoritePassword(m_aServerAddressStr);
        if(!pPassword)
            pPassword = Config()->m_Password;
        str_copy(m_aServerPassword, pPassword, sizeof(m_aServerPassword));

        CMsgPacker Msg(NETMSG_INFO, true);
        Msg.AddString(<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L8">GameClient()->NetVersion()</a>, 128);
        Msg.AddString(m_aServerPassword, 128);
        Msg.AddInt(<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L9">GameClient()->ClientVersion()</a>);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            Received by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L830-L857">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    if(Msg == NETMSG_INFO)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_AUTH)
        {
            const char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);
            if(str_comp(pVersion, GameServer()->NetVersion()) != 0)
            {
                // wrong version
                char aReason[256];
                str_format(aReason, sizeof(aReason), "Wrong version. Server is running '%s' and client '%s'", GameServer()->NetVersion(), pVersion);
                m_NetServer.Drop(ClientID, aReason);
                return;
            }

            const char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);
            if(Config()->m_Password[0] != 0 && str_comp(Config()->m_Password, pPassword) != 0)
            {
                // wrong password
                m_NetServer.Drop(ClientID, "Wrong password");
                return;
            }

            m_aClients[ClientID].m_Version = Unpacker.GetInt();

            m_aClients[ClientID].m_State = CClient::STATE_CONNECTING;
            SendMap(ClientID);
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_MAP_CHANGE"><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>2</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_INFO">NETMSG_INFO</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a> | <br>
                        <a href="system_messages.html#NETMSG_READY">NETMSG_READY</a>
                    </td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_name"><a href="#NETMSG_MAP_CHANGE_map_name">Map name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        Name of the map. The client will use this name and the crc to lookup
                        if it already has the map in the downloadedmaps/ folder
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_crc"><a href="#NETMSG_MAP_CHANGE_crc">Crc</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The Cyclic redundancy check (Crc) hash is used to differentiate between different maps
                        that share the same name.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_size"><a href="#NETMSG_MAP_CHANGE_map_size">Map size</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The size of the map in bytes.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_chunks_per_request"><a href="#NETMSG_MAP_CHANGE_chunks_per_request">Chunks per request</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The value is coming from the servers config option <code>sv_map_download_speed</code>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_chunk_size"><a href="#NETMSG_MAP_CHANGE_chunk_size">Chunk size</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        Since the map download chunks contain an unterminated raw data field
                        the server is informing the client here how big that data field is.
                        It is sending <code>MAP_CHUNK_SIZE</code> which is defined as
                        <code>MAP_CHUNK_SIZE=NET_MAX_PAYLOAD-NET_MAX_CHUNKHEADERSIZE-4</code>
                        which evalutes to <code>1384</code>.
                        So on a unmodified vanilla server this will always be the fixed value
                        <code>1384</code> but custom servers could change it and the client
                        should technically support that.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_sha256"><a href="#NETMSG_MAP_CHANGE_map_sha256">Map sha256</a></td>
                    <td><a href="fundamentals.html#raw_packing">Raw</a></td>
                    <td>
                        Since crc is a weak hashing alorithm this new field was added
                        to avoid hash collisions and better differentiate maps with the same name.
                        It was added as a security update since the crc collision was attackable.
                        And one could trick clients into thinking they know a certain map already.
                        <br>
                        There is no length field for this raw field. Client and server use the fixed
                        pre agreed size <code>SHA256_DIGEST_LENGTH</code> (32)
                    </td>
                </tr>
            </table>
            Sent when client should switch map and on initial join.
            <br>
            Sent by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L709-L719">
                CServer::SendMap(int ClientID)
            </a>
            <pre class="code-snippet">
                <code>
    CMsgPacker Msg(NETMSG_MAP_CHANGE, true);
    Msg.AddString(GetMapName(), 0);
    Msg.AddInt(m_CurrentMapCrc);
    Msg.AddInt(m_CurrentMapSize);
    Msg.AddInt(m_MapChunksPerRequest);
    Msg.AddInt(MAP_CHUNK_SIZE);
    Msg.AddRaw(&m_CurrentMapSha256, sizeof(m_CurrentMapSha256));
    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);
                </code>
            </pre>
            Unpacked by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/master/src/engine/client/client.cpp#L1150-L1222">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    const char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES);
    int MapCrc = Unpacker.GetInt();
    int MapSize = Unpacker.GetInt();
    int MapChunkNum = Unpacker.GetInt();
    int MapChunkSize = Unpacker.GetInt();
    if(Unpacker.Error())
        return;
    const SHA256_DIGEST *pMapSha256 = (const SHA256_DIGEST *)Unpacker.GetRaw(sizeof(*pMapSha256));
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_MAP_DATA"><a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>3</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_READY">NETMSG_READY</a></td>
                </tr>
            </table>
            map transfer, contains a chunk of the map file <br>
            If the client did send a <a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a>.
            The server will respond with those map chunk messages in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L858-L891">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_REQUEST_MAP_DATA)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            int ChunkSize = MAP_CHUNK_SIZE;

            // send map chunks
            for(int i = 0; i < m_MapChunksPerRequest && m_aClients[ClientID].m_MapChunk >= 0; ++i)
            {
                int Chunk = m_aClients[ClientID].m_MapChunk;
                int Offset = Chunk * ChunkSize;

                // check for last part
                if(Offset+ChunkSize >= m_CurrentMapSize)
                {
                    ChunkSize = m_CurrentMapSize-Offset;
                    m_aClients[ClientID].m_MapChunk = -1;
                }
                else
                    m_aClients[ClientID].m_MapChunk++;

                CMsgPacker Msg(NETMSG_MAP_DATA, true);
                Msg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);
                SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);

                if(Config()->m_Debug)
                {
                    char aBuf[64];
                    str_format(aBuf, sizeof(aBuf), "sending chunk %d with size %d", Chunk, ChunkSize);
                    Console()->Print(IConsole::OUTPUT_LEVEL_DEBUG, "server", aBuf);
                }
            }
        }
    }
                </code>
            </pre>
            The client then unpacks them in
            <a href="">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA)
    {
        if(!m_MapdownloadFileTemp)
            return;

        int Size = minimum(m_MapDownloadChunkSize, m_MapdownloadTotalsize-m_MapdownloadAmount);
        const unsigned char *pData = Unpacker.GetRaw(Size);
                </code>
            </pre>
            The client uses the <code>m_MapDownloadChunkSize</code>
            as size of the raw field. This variable was set to the value
            of the <a href="#NETMSG_MAP_CHANGE_chunk_size">Chunk Size</a> field from the
            <a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> message.
        </p>
        <hr>
        <h2 id="NETMSG_SERVERINFO"><a href="#NETMSG_SERVERINFO">NETMSG_SERVERINFO</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>4</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            The server sends the server info to every client that joins.
            After the client did send the <a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a> message.
            Or if a server admin does change the server info it will be resend it to all clients.
            By setting the rcon variables <code>sv_name</code>, <code>password</code> or <code>sv_max_clients</code>.<br>
            It is sent via the function
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L1151-L1165">
                CServer::SendServerInfo(int ClientID)
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendServerInfo(int ClientID)
    {
        CMsgPacker Msg(NETMSG_SERVERINFO, true);
        GenerateServerInfo(&Msg, -1);
        if(ClientID == -1)
        {
            for(int i = 0; i < MAX_CLIENTS; i++)
            {
                if(m_aClients[i].m_State != CClient::STATE_EMPTY)
                    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, i);
            }
        }
        else if(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State != CClient::STATE_EMPTY)
            SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);
    }
                </code>
            </pre>
            It will be unpacked by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1271-L1281">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_SERVERINFO)
    {
        <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/serverbrowser.h#L10-L71">CServerInfo</a> Info = {0};
        net_addr_str(&pPacket->m_Address, Info.m_aAddress, sizeof(Info.m_aAddress), true);
        if(!<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L923-L988">UnpackServerInfo(&Unpacker, &Info, 0)</a> && !Unpacker.Error())
        {
            SortClients(&Info);
            mem_copy(&m_CurrentServerInfo, &Info, sizeof(m_CurrentServerInfo));
            m_CurrentServerInfo.m_NetAddr = m_ServerAddress;
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_CON_READY"><a href="#NETMSG_CON_READY">NETMSG_CON_READY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>5</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_READY">NETMSG_READY</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="game_messages.html#NETMSGTYPE_CL_STARTINFO">NETMSGTYPE_CL_STARTINFO</a></td>
                </tr>
            </table>

            The server sends this to the client when the connection is ready.
            It also tells the client to now send the startinfo.
            <br>
            <br>
            After the server did receive a <a href="#NETMSG_READY">NETMSG_READY</a> from the client.
            It will respond with this message in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L892-L908">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_READY)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player is ready. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, "server", aBuf);

            bool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;
            m_aClients[ClientID].m_State = CClient::STATE_READY;
            GameServer()->OnClientConnected(ClientID, ConnectAsSpec);
            SendConnectionReady(ClientID);
        }
    }
                </code>
            </pre>
            If the client does receive it it will call GameClient()->OnConnected()
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY)
    {
        GameClient()->OnConnected();
    }
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    void CGameClient::OnConnected()
    {
        m_Layers.Init(Kernel());
        m_Collision.Init(Layers());

        for(int i = 0; i < m_All.m_Num; i++)
        {
            m_All.m_paComponents[i]->OnMapLoad();
            m_All.m_paComponents[i]->OnReset();
        }

        m_ServerMode = SERVERMODE_PURE;

        // send the inital info
        SendStartInfo();
    }
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    void CGameClient::SendStartInfo()
    {
        CNetMsg_Cl_StartInfo Msg;
        Msg.m_pName = Config()->m_PlayerName;
        Msg.m_pClan = Config()->m_PlayerClan;
        Msg.m_Country = Config()->m_PlayerCountry;
        for(int p = 0; p < NUM_SKINPARTS; p++)
        {
            Msg.m_apSkinPartNames[p] = CSkins::ms_apSkinVariables[p];
            Msg.m_aUseCustomColors[p] = *CSkins::ms_apUCCVariables[p];
            Msg.m_aSkinPartColors[p] = *CSkins::ms_apColorVariables[p];
        }
        Client()->SendPackMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_SNAP"><a href="#NETMSG_SNAP">NETMSG_SNAP</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>6</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            normal snapshot, multiple parts <br>
            Will be sent by the server to every client if there is
            new snap data.
        </p>
        <hr>
        <h2 id="NETMSG_SNAPEMPTY"><a href="#NETMSG_SNAPEMPTY">NETMSG_SNAPEMPTY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>7</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            empty snapshot
        </p>
        <hr>
        <h2 id="NETMSG_SNAPSINGLE"><a href="#NETMSG_SNAPSINGLE">NETMSG_SNAPSINGLE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>8</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_SNAPSMALL"><a href="#NETMSG_SNAPSMALL">NETMSG_SNAPSMALL</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>9</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_INPUTTIMING"><a href="#NETMSG_INPUTTIMING">NETMSG_INPUTTIMING</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>10</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_INPUT">NETMSG_INPUT</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            reports how off the input was <br>
            The server responds this to all the input messages from the clients in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L924-L980">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    // add message to report the input timing
    // skip packets that are old
    if(IntendedTick > m_aClients[ClientID].m_LastInputTick)
    {
        int TimeLeft = ((TickStartTime(IntendedTick)-Now)*1000) / time_freq();

        CMsgPacker Msg(NETMSG_INPUTTIMING, true);
        Msg.AddInt(IntendedTick);
        Msg.AddInt(TimeLeft);
        SendMsg(&Msg, 0, ClientID);
    }
                </code>
            </pre>
            The client uses this data to correct its prediction in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1342-L1361">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_INPUTTIMING)
    {
        int InputPredTick = Unpacker.GetInt();
        int TimeLeft = Unpacker.GetInt();

        // adjust our prediction time
        int64 Target = 0;
        for(int k = 0; k < 200; k++)
        {
            if(m_aInputs[k].m_Tick == InputPredTick)
            {
                Target = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time);
                Target = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq());
                break;
            }
        }

        if(Target)
            m_PredictedTime.Update(&m_InputtimeMarginGraph, Target, TimeLeft, 1);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH_ON"><a href="#NETMSG_RCON_AUTH_ON">NETMSG_RCON_AUTH_ON</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>11</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            If the client did send the correct rcon admin or mod password.
            The server sends this to inform the client that the rcon console is now enabled.
            <pre class="code-snippet">
                <code>
    else if(Config()->m_SvRconPassword[0] && str_comp(pPw, Config()->m_SvRconPassword) == 0)
    {
        CMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    else if(Config()->m_SvRconModPassword[0] && str_comp(pPw, Config()->m_SvRconModPassword) == 0)
    {
        CMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
                </code>
            </pre>

            The client sets <code>m_RconAuthed</code> to true (1) on receival.
            Which enables the rcon prompt in the client UI.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_ON)
    {
        m_RconAuthed = 1;
        m_UseTempRconCommands = 1;
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH_OFF"><a href="#NETMSG_RCON_AUTH_OFF">NETMSG_RCON_AUTH_OFF</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>12</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> (<code>logout</code>)</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            rcon authentication disabled
            The server sends this when an admin executes the <code>logout</code> rcon command.
            <pre class="code-snippet">
                <code>
    void CServer::ConLogout(IConsole::IResult *pResult, void *pUser)
    {
        CServer *pServer = (CServer *)pUser;
    
        if(pServer->m_RconClientID >= 0 && pServer->m_RconClientID < MAX_CLIENTS &&
            pServer->m_aClients[pServer->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)
        {
            CMsgPacker Msg(NETMSG_RCON_AUTH_OFF, true);
            pServer->SendMsg(&Msg, MSGFLAG_VITAL, pServer->m_RconClientID);
    
            pServer->m_aClients[pServer->m_RconClientID].m_Authed = AUTHED_NO;
            pServer->m_aClients[pServer->m_RconClientID].m_AuthTries = 0;
            pServer->m_aClients[pServer->m_RconClientID].m_pRconCmdToSend = 0;
            pServer->m_aClients[pServer->m_RconClientID].m_pMapListEntryToSend = 0;
            pServer->SendRconLine(pServer->m_RconClientID, "Logout successful.");
            char aBuf[32];
            str_format(aBuf, sizeof(aBuf), "ClientID=%d logged out", pServer->m_RconClientID);
            pServer->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, "server", aBuf);
        }
    }
                </code>
            </pre>
            If the client gets this message it sets <code>m_RconAuthed</code> to false (0)
            which deactivates the rcon prompt in the client UI.
            It also deletes all rcon commands the server sent to the client during the time
            the client was authed.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_OFF)
    {
        m_RconAuthed = 0;
        if(m_UseTempRconCommands)
            m_pConsole->DeregisterTempAll();
        m_UseTempRconCommands = 0;
        m_pConsole->DeregisterTempMapAll();
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_LINE"><a href="#NETMSG_RCON_LINE">NETMSG_RCON_LINE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>13</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> | <a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            Line that should be printed to the remote console.
            <br>
            All messages that show up in the clients rcon console are coming from this message.
            They are send by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L727-L732">
                CServer::SendRconLine(int ClientID, const char *pLine)
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendRconLine(int ClientID, const char *pLine)
    {
        CMsgPacker Msg(NETMSG_RCON_LINE, true);
        Msg.AddString(pLine, 512);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            <br>
            If the client gets this packet. It adds the payload (line) into
            the console log where the rendere can pick it up if the user
            opens the rcon console.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE)
    {
        const char *pLine = Unpacker.GetString();
        if(Unpacker.Error() == 0)
            <a href="https://github.com/teeworlds/teeworlds/blob/master/src/game/client/gameclient.cpp#L1050-L1053">GameClient()->OnRconLine(pLine);</a>
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD_ADD"><a href="#NETMSG_RCON_CMD_ADD">NETMSG_RCON_CMD_ADD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>14</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            The server will send his list of rcon commands with parameters and help text
            to all authenticated clients. So after the client did authenticate the server starts sending
            NETMSG_RCON_CMD_ADD messages. There is a rate limit that avoid flooding the client
            with too much data. That is why when you authenticate to rcon and press tab to
            see the list of autocompletions they only show up after some time.
            The server uses the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L751-L758">
                SendRconCmdAdd()
            </a>
            method to send them which is called on tick if the ratelimit is not exceeded and the target client
            is authenticated.
            <pre class="code-snippet">
                <code>
    void CServer::SendRconCmdAdd(const IConsole::CCommandInfo *pCommandInfo, int ClientID)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD_ADD, true);
        Msg.AddString(pCommandInfo->m_pName, IConsole::TEMPCMD_NAME_LENGTH);
        Msg.AddString(pCommandInfo->m_pHelp, IConsole::TEMPCMD_HELP_LENGTH);
        Msg.AddString(pCommandInfo->m_pParams, IConsole::TEMPCMD_PARAMS_LENGTH);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            The client then receives them in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1291-L1298">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            where it stores them into the autocompletion list used by the remote console UI.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD)
    {
        const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        const char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        const char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        if(Unpacker.Error() == 0)
            m_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD_REM"><a href="#NETMSG_RCON_CMD_REM">NETMSG_RCON_CMD_REM</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>15</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> (mod_command)</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            This is the opposite as <a href="#NETMSG_RCON_CMD_ADD">NETMSG_RCON_CMD_ADD</a>.
            And is used by the server to remove commands from the clients known command list.
            While adding takes three parameters: name, parameters and help text. Removing
            only needs the name and the client will remove the whole commany entry that matches the name.
            This is only sent to moderators when an admin updates the list of commands
            accessible to moderators (using the rcon command
            <code>
                <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/shared/console.cpp#L824">
                    mod_command
                </a>
            </code>).
            The method sending this message is
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L760-L765">
                SendRconCmdRem()
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendRconCmdRem(const IConsole::CCommandInfo *pCommandInfo, int ClientID)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD_REM, true);
        Msg.AddString(pCommandInfo->m_pName, 256);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            If the client receives it it will remove the command with the given name
            from its list of known commands in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1299-L1304">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM)
    {
        const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        if(Unpacker.Error() == 0)
            m_pConsole->DeregisterTemp(pName);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_CHALLANGE"><a href="#NETMSG_AUTH_CHALLANGE">NETMSG_AUTH_CHALLANGE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>16</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            Seems to be unused
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_RESULT"><a href="#NETMSG_AUTH_RESULT">NETMSG_AUTH_RESULT</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>17</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            Seems to be unused
        </p>
        <hr>
        <h2 id="NETMSG_READY"><a href="#NETMSG_READY">NETMSG_READY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>18</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> | <a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_CON_READY">NETMSG_CON_READY</a></td>
                </tr>
            </table>
            The client sends this to the server when it finished downloading the map
            or when it wants to skip the map download because it already has it in the downloadedmaps/ folder.
            The client uses the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L362-L366">
                CClient::SendReady()
            </a>
            method to send this message.
            <pre class="code-snippet">
                <code>
    void CClient::SendReady()
    {
        CMsgPacker Msg(NETMSG_READY, true);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            The server calls
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">
                SendConnectionReady(ClientID);
            </a>
            when it receives this message in the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L892-L908">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            method
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_READY)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player is ready. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, "server", aBuf);

            bool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;
            m_aClients[ClientID].m_State = CClient::STATE_READY;
            GameServer()->OnClientConnected(ClientID, ConnectAsSpec);
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">SendConnectionReady(ClientID);</a>
        }
    }
                </code>
            </pre>
            The
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">
                SendConnectionReady(ClientID);
            </a>
            then sends the <a href="#NETMSG_CON_READY">NETMSG_CON_READY</a> as a response to the client.
        </p>
        <hr>
        <h2 id="NETMSG_ENTERGAME"><a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>19</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="game_messages.html#NETMSGTYPE_SV_READYTOENTER">NETMSGTYPE_SV_READYTOENTER</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="game_messages.html#NETMSGTYPE_SV_COMMANDINFO">NETMSGTYPE_SV_COMMANDINFO</a> & <br>
                        <a href="#NETMSG_SERVERINFO">NETMSG_SERVERINFO</a> & <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_GAMEINFO">NETMSGTYPE_SV_GAMEINFO</a> & <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_CLIENTINFO">NETMSGTYPE_SV_CLIENTINFO</a>
                    </td>
                </tr>
            </table>
            Sent by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L356-L360">
                CClient::SendEnterGame()
            </a>
            <pre class="code-snippet">
                <code>
    void CClient::SendEnterGame()
    {
        CMsgPacker Msg(NETMSG_ENTERGAME, true);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            The server processes this message in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L909-L923">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_ENTERGAME)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player has entered the game. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, "server", aBuf);
            m_aClients[ClientID].m_State = CClient::STATE_INGAME;
            SendServerInfo(ClientID);
            GameServer()->OnClientEnter(ClientID);
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_INPUT"><a href="#NETMSG_INPUT">NETMSG_INPUT</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>20</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Sent on changed user input</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_INPUTTIMING">NETMSG_INPUTTIMING</a></td>
                </tr>
            </table>
            Contains the inputdata from the client (hook/walk/fire/meta data and more).
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD"><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>21</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Sent when the client submits a rcon command</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        [ <a href="#NETMSG_RCON_LINE">NETMSG_RCON_LINE</a> ] | <br>
                        [ <a href="#NETMSG_RCON_AUTH_OFF">NETMSG_RCON_AUTH_OFF</a> ]
                    </td>
                </tr>
            </table>
            <br>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td>Command</td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>The rcon command like for example <code>status</code> or <code>shutdown</code></td>
                </tr>
            </table>
            <br>
            Sent by the client using the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L378-L383">
                CClient::Rcon(const char *pCmd)
            </a>
            method.
            <pre class="code-snippet">
                <code>
    void CClient::Rcon(const char *pCmd)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD, true);
        Msg.AddString(pCmd, 256);
        SendMsg(&Msg, MSGFLAG_VITAL);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH"><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>22</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_REQUEST_MAP_DATA"><a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>23</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_START"><a href="#NETMSG_AUTH_START">NETMSG_AUTH_START</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>24</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_RESPONSE"><a href="#NETMSG_AUTH_RESPONSE">NETMSG_AUTH_RESPONSE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>25</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_PING"><a href="#NETMSG_PING">NETMSG_PING</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>26</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a></td>
                </tr>
            </table>
            sent by both
        </p>
        <hr>
        <h2 id="NETMSG_PING_REPLY"><a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>27</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
            sent by both
        </p>
        <hr>
        <h2 id="NETMSG_ERROR"><a href="#NETMSG_ERROR">NETMSG_ERROR</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>28</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
            sent by both
        </p>
        <hr>
        <h2 id="NETMSG_MAPLIST_ENTRY_ADD"><a href="#NETMSG_MAPLIST_ENTRY_ADD">NETMSG_MAPLIST_ENTRY_ADD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>29</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
            the msg id is planned to be changed in 0.8
        </p>
        <hr>
        <h2 id="NETMSG_MAPLIST_ENTRY_REM"><a href="#NETMSG_MAPLIST_ENTRY_REM">NETMSG_MAPLIST_ENTRY_REM</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>30</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>TODO</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>TODO</td>
                </tr>
            </table>
            the msg id is planned to be changed in 0.8
        </p>
    </div> <!-- content -->
    <footer>
        <hr>
        <div class="footer">
            <!-- Icon-link to source code on GitHub -->
            <a class="github" href="https://github.com/ChillerDragon/teeworlds-protocol" target="_blank" rel="noopener" aria-label="Source code">
                <!-- icon: https://materialdesignicons.com/icon/github -->
                <svg viewBox="0 0 24 24" class="github">
                    <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" />
                </svg>
            </a>
            <span>
                ChillerDragon - 2023
            </span>
        </div>
    </footer>
</body>
