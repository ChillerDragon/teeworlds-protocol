<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="../css/style.css">
    <title>Teeworlds Protocol</title>
</head>
<body>
    <div class="header">
        <a href="../index.html">
            <img src="../img/tee.svg" alt="tee">
        </a>
        <a href="../index.html">home</a>
        <a href="../07.html">overview</a>
        <a href="fundamentals.html">fundamentals</a>
        <a href="traffic.html">traffic</a>
        <a href="map_download.html">map_download</a>
        <a href="snap_items.html">snap_items</a>
        <a href="system_messages.html">system_messages</a>
        <a href="game_messages.html">game_messages</a>
        <a href="ctrl_messages.html">ctrl_messages</a>
        <hr>
    </div>
    <div class="content">
        <h1>List of network system messages</h1>
        <p>
            There are three types of messages with overlapping message ids: <br>
            <a href="system_messages.html">system messages</a>,
            <a href="game_messages.html">game messages</a> and
            <a href="ctrl_messages.html">control messages</a>
            <br>
            This list is only covering system messages.
            <br>
            <br>
            When the client and server exchange packets.
            An integer field which usually does not exceed one byte.
            Is indicating which type of message was sent.
            This field is called the message id.
            These message ids are defined in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/shared/protocol.h#L31-L76">
                src/engine/shared/protocol.h
            </a>
            and their payload is defined where they are sent and received.
            There can be multiple messages in so called chunks in one teeworlds packet.
            <br>
            <br>
            In the list below you will find those message.
            With their name, id and payload.
        </p>
        <hr>
        <h2 id="NETMSG_NULL"><a href="#NETMSG_NULL">NETMSG_NULL</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Message ID:</strong></th><td>0</td>
                </tr>
            </table>
            <br>
        </p>
        <hr>
        <h2 id="NETMSG_INFO"><a href="#NETMSG_INFO">NETMSG_INFO</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>1</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="ctrl_messages.html#NET_CTRLMSG_ACCEPT">NET_CTRLMSG_ACCEPT</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_net_version"><a href="#NETMSG_INFO_net_version">Net Version</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        The official name is "NetVersion" but a more fitting name in my opinion would be "Protocol Version".
                        <br>
                        The variable <code>GAME_NETVERSION</code> always expands to <code>"0.7 802f1be60a05665f"</code><br>
                        If the server gets another string it actually rejects the connection. This is what prohibits
                        0.6 clients to join 0.7 servers.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_password"><a href="#NETMSG_INFO_password">Password</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        If the config option <code>password</code> is set on the server. This password has to match to join the server.
                        The vanilla 0.7 client always sends the last used passwords to all servers no matter if they expect a password or not.
                        And servers simply ignore this field if no password is expected.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INFO_client_version"><a href="#NETMSG_INFO_client_version">Client Version</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        Another version field which does not have to match the servers
                        version to establish a connection. The first net version field makes sure
                        that client and server use the same major protocol and are compatible.
                        This "Client Version" field then informs the server about the clients minor version.
                        The server can use it to activate some non protocol breaking features
                        that were introduced in minor releases.
                    </td>
                </tr>
            </table>
            <br>
            Sent by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L340-L353">
                CClient::SendInfo()
            </a>
            <pre class="code-snippet">
                <code>
    void CClient::SendInfo()
    {
        // restore password of favorite if possible
        const char *pPassword = m_ServerBrowser.GetFavoritePassword(m_aServerAddressStr);
        if(!pPassword)
            pPassword = Config()->m_Password;
        str_copy(m_aServerPassword, pPassword, sizeof(m_aServerPassword));

        CMsgPacker Msg(NETMSG_INFO, true);
        Msg.AddString(<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L8">GameClient()->NetVersion()</a>, 128);
        Msg.AddString(m_aServerPassword, 128);
        Msg.AddInt(<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/version.h#L9">GameClient()->ClientVersion()</a>);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            Received by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L830-L857">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    if(Msg == NETMSG_INFO)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_AUTH)
        {
            const char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);
            if(str_comp(pVersion, GameServer()->NetVersion()) != 0)
            {
                // wrong version
                char aReason[256];
                str_format(aReason, sizeof(aReason), "Wrong version. Server is running '%s' and client '%s'", GameServer()->NetVersion(), pVersion);
                m_NetServer.Drop(ClientID, aReason);
                return;
            }

            const char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);
            if(Config()->m_Password[0] != 0 && str_comp(Config()->m_Password, pPassword) != 0)
            {
                // wrong password
                m_NetServer.Drop(ClientID, "Wrong password");
                return;
            }

            m_aClients[ClientID].m_Version = Unpacker.GetInt();

            m_aClients[ClientID].m_State = CClient::STATE_CONNECTING;
            SendMap(ClientID);
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_MAP_CHANGE"><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>2</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_INFO">NETMSG_INFO</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a> | <br>
                        <a href="system_messages.html#NETMSG_READY">NETMSG_READY</a>
                    </td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_name"><a href="#NETMSG_MAP_CHANGE_map_name">Map name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        Name of the map. The client will use this name and the crc to lookup
                        if it already has the map in the downloadedmaps/ folder
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_crc"><a href="#NETMSG_MAP_CHANGE_crc">Crc</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The Cyclic redundancy check (Crc) hash is used to differentiate between different maps
                        that share the same name.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_size"><a href="#NETMSG_MAP_CHANGE_map_size">Map size</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The size of the map in bytes.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_chunks_per_request"><a href="#NETMSG_MAP_CHANGE_chunks_per_request">Chunks per request</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        The value is coming from the servers config option <code>sv_map_download_speed</code>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_chunk_size"><a href="#NETMSG_MAP_CHANGE_chunk_size">Chunk size</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        Since the map download chunks contain an unterminated raw data field
                        the server is informing the client here how big that data field is.
                        It is sending <code>MAP_CHUNK_SIZE</code> which is defined as
                        <code>MAP_CHUNK_SIZE=NET_MAX_PAYLOAD-NET_MAX_CHUNKHEADERSIZE-4</code>
                        which evalutes to <code>1384</code>.
                        So on a unmodified vanilla server this will always be the fixed value
                        <code>1384</code> but custom servers could change it and the client
                        should technically support that.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_CHANGE_map_sha256"><a href="#NETMSG_MAP_CHANGE_map_sha256">Map sha256</a></td>
                    <td><a href="fundamentals.html#raw_packing">Raw</a></td>
                    <td>
                        Since crc is a weak hashing alorithm this new field was added
                        to avoid hash collisions and better differentiate maps with the same name.
                        It was added as a security update since the crc collision was attackable.
                        And one could trick clients into thinking they know a certain map already.
                        <br>
                        There is no length field for this raw field. Client and server use the fixed
                        pre agreed size <code>SHA256_DIGEST_LENGTH</code> (32)
                    </td>
                </tr>
            </table>
            Sent when client should switch map and on initial join.
            <br>
            See the <a href="map_download.html">map_download</a> section for a higher level overview.
            <br>
            <br>
            Sent by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L709-L719">
                CServer::SendMap(int ClientID)
            </a>
            <pre class="code-snippet">
                <code>
    CMsgPacker Msg(NETMSG_MAP_CHANGE, true);
    Msg.AddString(GetMapName(), 0);
    Msg.AddInt(m_CurrentMapCrc);
    Msg.AddInt(m_CurrentMapSize);
    Msg.AddInt(m_MapChunksPerRequest);
    Msg.AddInt(MAP_CHUNK_SIZE);
    Msg.AddRaw(&m_CurrentMapSha256, sizeof(m_CurrentMapSha256));
    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);
                </code>
            </pre>
            Unpacked by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/master/src/engine/client/client.cpp#L1150-L1222">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    const char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES);
    int MapCrc = Unpacker.GetInt();
    int MapSize = Unpacker.GetInt();
    int MapChunkNum = Unpacker.GetInt();
    int MapChunkSize = Unpacker.GetInt();
    if(Unpacker.Error())
        return;
    const SHA256_DIGEST *pMapSha256 = (const SHA256_DIGEST *)Unpacker.GetRaw(sizeof(*pMapSha256));
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_MAP_DATA"><a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>3</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_READY">NETMSG_READY</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_MAP_DATA_map_data"><a href="#NETMSG_MAP_DATA_map_data">Map data</a></td>
                    <td><a href="fundamentals.html#raw_packing">Raw</a></td>
                    <td>
                        This message contains individual pieces of the whole map file.
                        They will be split in chunks of size <code>MAP_CHUNK_SIZE</code>
                        usually <code>1384</code> or a custom value provided by the server
                        in the <a href="#NETMSG_MAP_CHANGE_chunk_size">chunk size</a> field of
                        the <a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> message
                    </td>
                </tr>
            </table>
            map transfer, contains a chunk of the map file <br>
            If the client did send a <a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a>.
            The server will respond with those map chunk messages in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L858-L891">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_REQUEST_MAP_DATA)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            int ChunkSize = MAP_CHUNK_SIZE;

            // send map chunks
            for(int i = 0; i < m_MapChunksPerRequest && m_aClients[ClientID].m_MapChunk >= 0; ++i)
            {
                int Chunk = m_aClients[ClientID].m_MapChunk;
                int Offset = Chunk * ChunkSize;

                // check for last part
                if(Offset+ChunkSize >= m_CurrentMapSize)
                {
                    ChunkSize = m_CurrentMapSize-Offset;
                    m_aClients[ClientID].m_MapChunk = -1;
                }
                else
                    m_aClients[ClientID].m_MapChunk++;

                CMsgPacker Msg(NETMSG_MAP_DATA, true);
                Msg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);
                SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);

                if(Config()->m_Debug)
                {
                    char aBuf[64];
                    str_format(aBuf, sizeof(aBuf), "sending chunk %d with size %d", Chunk, ChunkSize);
                    Console()->Print(IConsole::OUTPUT_LEVEL_DEBUG, "server", aBuf);
                }
            }
        }
    }
                </code>
            </pre>
            The client then unpacks them in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1223-L1270">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA)
    {
        if(!m_MapdownloadFileTemp)
            return;

        int Size = minimum(m_MapDownloadChunkSize, m_MapdownloadTotalsize-m_MapdownloadAmount);
        const unsigned char *pData = Unpacker.GetRaw(Size);

        // [..]
                </code>
            </pre>
            The client uses the <code>m_MapDownloadChunkSize</code>
            as size of the raw field. This variable was set to the value
            of the <a href="#NETMSG_MAP_CHANGE_chunk_size">Chunk Size</a> field from the
            <a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> message.
            <br>
            <br>
            See the <a href="map_download.html">map_download</a> section for a higher level overview.
        </p>
        <hr>
        <h2 id="NETMSG_SERVERINFO"><a href="#NETMSG_SERVERINFO">NETMSG_SERVERINFO</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>4</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th>
                    <td>
                        <a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a> | <br>
                        <a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> (<code>sv_name</code>, <code>password</code>, <code>sv_max_clients</code>)
                    </td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_game_version"><a href="#NETMSG_SERVERINFO_game_version">Game version</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_name"><a href="#NETMSG_SERVERINFO_name">Name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_hostname"><a href="#NETMSG_SERVERINFO_hostname">Hostname</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_map_name"><a href="#NETMSG_SERVERINFO_map_name">Map name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_game_type"><a href="#NETMSG_SERVERINFO_game_type">Game type</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_flags"><a href="#NETMSG_SERVERINFO_flags">Flags</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        There are only two possible flags
                        <code>SERVERINFO_FLAG_PASSWORD</code>
                        and
                        <code>SERVERINFO_FLAG_TIMESCORE</code>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_skill_level"><a href="#NETMSG_SERVERINFO_skill_level">Skill level</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_player_count"><a href="#NETMSG_SERVERINFO_player_count">Player count</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_player_slots"><a href="#NETMSG_SERVERINFO_player_slots">Player slots</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_client_count"><a href="#NETMSG_SERVERINFO_client_count">Client count</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_SERVERINFO_max_clients"><a href="#NETMSG_SERVERINFO_max_clients">Max clients</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
            </table>
            <strong>Note:</strong>
            A similar structure with a few different fields is used for
            the server info request the server list uses (prefixed with "inf3").
            But this is only documenting the client server connection specific message
            and ignoring everything that is master server related.
            <br>
            <br>
            The server sends the server info to every client that joins.
            After the client did send the <a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a> message.
            Or if a server admin does change the server info it will be resend it to all clients.
            By setting the rcon variables <code>sv_name</code>, <code>password</code> or <code>sv_max_clients</code>.<br>
            It is sent via the function
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L1151-L1165">
                CServer::SendServerInfo(int ClientID)
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendServerInfo(int ClientID)
    {
        CMsgPacker Msg(NETMSG_SERVERINFO, true);
        GenerateServerInfo(&Msg, -1);
        if(ClientID == -1)
        {
            for(int i = 0; i < MAX_CLIENTS; i++)
            {
                if(m_aClients[i].m_State != CClient::STATE_EMPTY)
                    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, i);
            }
        }
        else if(ClientID >= 0 && ClientID < MAX_CLIENTS && m_aClients[ClientID].m_State != CClient::STATE_EMPTY)
            SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID);
    }
                </code>
            </pre>
            It will be unpacked by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1271-L1281">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_SERVERINFO)
    {
        <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/serverbrowser.h#L10-L71">CServerInfo</a> Info = {0};
        net_addr_str(&pPacket->m_Address, Info.m_aAddress, sizeof(Info.m_aAddress), true);
        if(!<a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L923-L988">UnpackServerInfo(&Unpacker, &Info, 0)</a> && !Unpacker.Error())
        {
            SortClients(&Info);
            mem_copy(&m_CurrentServerInfo, &Info, sizeof(m_CurrentServerInfo));
            m_CurrentServerInfo.m_NetAddr = m_ServerAddress;
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_CON_READY"><a href="#NETMSG_CON_READY">NETMSG_CON_READY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>5</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_READY">NETMSG_READY</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="game_messages.html#NETMSGTYPE_CL_STARTINFO">NETMSGTYPE_CL_STARTINFO</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            The server sends this to the client when the connection is ready.
            It also tells the client to now send the startinfo.
            <br>
            <br>
            After the server did receive a <a href="#NETMSG_READY">NETMSG_READY</a> from the client.
            It will respond with this message in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L892-L908">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_READY)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player is ready. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, "server", aBuf);

            bool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;
            m_aClients[ClientID].m_State = CClient::STATE_READY;
            GameServer()->OnClientConnected(ClientID, ConnectAsSpec);
            <a href="https://github.com/teeworlds/teeworlds/blob/master/src/engine/server/server.cpp#L721-L725">SendConnectionReady(ClientID);</a>
        }
    }
                </code>
            </pre>
            If the client does receive it it will call GameClient()->OnConnected()
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY)
    {
        <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/game/client/gameclient.cpp#L453-L468">GameClient()->OnConnected();</a>
    }
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    void CGameClient::OnConnected()
    {
        m_Layers.Init(Kernel());
        m_Collision.Init(Layers());

        for(int i = 0; i < m_All.m_Num; i++)
        {
            m_All.m_paComponents[i]->OnMapLoad();
            m_All.m_paComponents[i]->OnReset();
        }

        m_ServerMode = SERVERMODE_PURE;

        // send the inital info
        SendStartInfo();
    }
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    void CGameClient::SendStartInfo()
    {
        CNetMsg_Cl_StartInfo Msg;
        Msg.m_pName = Config()->m_PlayerName;
        Msg.m_pClan = Config()->m_PlayerClan;
        Msg.m_Country = Config()->m_PlayerCountry;
        for(int p = 0; p < NUM_SKINPARTS; p++)
        {
            Msg.m_apSkinPartNames[p] = CSkins::ms_apSkinVariables[p];
            Msg.m_aUseCustomColors[p] = *CSkins::ms_apUCCVariables[p];
            Msg.m_aSkinPartColors[p] = *CSkins::ms_apColorVariables[p];
        }
        Client()->SendPackMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_SNAP"><a href="#NETMSG_SNAP">NETMSG_SNAP</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>6</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            normal snapshot, multiple parts <br>
            Will be sent by the server to every client if there is
            new snap data.
        </p>
        <hr>
        <h2 id="NETMSG_SNAPEMPTY"><a href="#NETMSG_SNAPEMPTY">NETMSG_SNAPEMPTY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>7</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            empty snapshot
        </p>
        <hr>
        <h2 id="NETMSG_SNAPSINGLE"><a href="#NETMSG_SNAPSINGLE">NETMSG_SNAPSINGLE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>8</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_SNAPSMALL"><a href="#NETMSG_SNAPSMALL">NETMSG_SNAPSMALL</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>9</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>None</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
        </p>
        <hr>
        <h2 id="NETMSG_INPUTTIMING"><a href="#NETMSG_INPUTTIMING">NETMSG_INPUTTIMING</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>10</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_INPUT">NETMSG_INPUT</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_INPUTTIMING_intended_tick"><a href="#NETMSG_INPUTTIMING_intended_tick">Intended tick</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUTTIMING_time_left"><a href="#NETMSG_INPUTTIMING_time_left">Time left</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
            </table>
            reports how off the input was <br>
            The server responds this to all the input messages from the clients in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L924-L980">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    // add message to report the input timing
    // skip packets that are old
    if(IntendedTick > m_aClients[ClientID].m_LastInputTick)
    {
        int TimeLeft = ((TickStartTime(IntendedTick)-Now)*1000) / time_freq();

        CMsgPacker Msg(NETMSG_INPUTTIMING, true);
        Msg.AddInt(IntendedTick);
        Msg.AddInt(TimeLeft);
        SendMsg(&Msg, 0, ClientID);
    }
                </code>
            </pre>
            The client uses this data to correct its prediction in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1342-L1361">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_INPUTTIMING)
    {
        int InputPredTick = Unpacker.GetInt();
        int TimeLeft = Unpacker.GetInt();

        // adjust our prediction time
        int64 Target = 0;
        for(int k = 0; k < 200; k++)
        {
            if(m_aInputs[k].m_Tick == InputPredTick)
            {
                Target = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time);
                Target = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq());
                break;
            }
        }

        if(Target)
            m_PredictedTime.Update(&m_InputtimeMarginGraph, Target, TimeLeft, 1);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH_ON"><a href="#NETMSG_RCON_AUTH_ON">NETMSG_RCON_AUTH_ON</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>11</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            If the client did send the correct rcon admin or mod password.
            The server sends this to inform the client that the rcon console is now enabled.
            <pre class="code-snippet">
                <code>
    else if(Config()->m_SvRconPassword[0] && str_comp(pPw, Config()->m_SvRconPassword) == 0)
    {
        CMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
                </code>
            </pre>
            <pre class="code-snippet">
                <code>
    else if(Config()->m_SvRconModPassword[0] && str_comp(pPw, Config()->m_SvRconModPassword) == 0)
    {
        CMsgPacker Msg(NETMSG_RCON_AUTH_ON, true);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
                </code>
            </pre>

            The client sets <code>m_RconAuthed</code> to true (1) on receival.
            Which enables the rcon prompt in the client UI.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_ON)
    {
        m_RconAuthed = 1;
        m_UseTempRconCommands = 1;
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH_OFF"><a href="#NETMSG_RCON_AUTH_OFF">NETMSG_RCON_AUTH_OFF</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>12</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> (<code>logout</code>)</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            rcon authentication disabled
            The server sends this when an admin executes the <code>logout</code> rcon command.
            <pre class="code-snippet">
                <code>
    void CServer::ConLogout(IConsole::IResult *pResult, void *pUser)
    {
        CServer *pServer = (CServer *)pUser;

        if(pServer->m_RconClientID >= 0 && pServer->m_RconClientID < MAX_CLIENTS &&
            pServer->m_aClients[pServer->m_RconClientID].m_State != CServer::CClient::STATE_EMPTY)
        {
            CMsgPacker Msg(NETMSG_RCON_AUTH_OFF, true);
            pServer->SendMsg(&Msg, MSGFLAG_VITAL, pServer->m_RconClientID);

            pServer->m_aClients[pServer->m_RconClientID].m_Authed = AUTHED_NO;
            pServer->m_aClients[pServer->m_RconClientID].m_AuthTries = 0;
            pServer->m_aClients[pServer->m_RconClientID].m_pRconCmdToSend = 0;
            pServer->m_aClients[pServer->m_RconClientID].m_pMapListEntryToSend = 0;
            pServer->SendRconLine(pServer->m_RconClientID, "Logout successful.");
            char aBuf[32];
            str_format(aBuf, sizeof(aBuf), "ClientID=%d logged out", pServer->m_RconClientID);
            pServer->Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, "server", aBuf);
        }
    }
                </code>
            </pre>
            If the client gets this message it sets <code>m_RconAuthed</code> to false (0)
            which deactivates the rcon prompt in the client UI.
            It also deletes all rcon commands the server sent to the client during the time
            the client was authed.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_OFF)
    {
        m_RconAuthed = 0;
        if(m_UseTempRconCommands)
            m_pConsole->DeregisterTempAll();
        m_UseTempRconCommands = 0;
        m_pConsole->DeregisterTempMapAll();
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_LINE"><a href="#NETMSG_RCON_LINE">NETMSG_RCON_LINE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>13</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> | <a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_LINE_cmd"><a href="#NETMSG_RCON_LINE_cmd">Command</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>Command or config variable with parameters</td>
                </tr>
            </table>
            Line that should be printed to the remote console.
            <br>
            All messages that show up in the clients rcon console are coming from this message.
            They are send by the server in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L727-L732">
                CServer::SendRconLine(int ClientID, const char *pLine)
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendRconLine(int ClientID, const char *pLine)
    {
        CMsgPacker Msg(NETMSG_RCON_LINE, true);
        Msg.AddString(pLine, 512);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            <br>
            If the client gets this packet. It adds the payload (line) into
            the console log where the rendere can pick it up if the user
            opens the rcon console.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE)
    {
        const char *pLine = Unpacker.GetString();
        if(Unpacker.Error() == 0)
            <a href="https://github.com/teeworlds/teeworlds/blob/master/src/game/client/gameclient.cpp#L1050-L1053">GameClient()->OnRconLine(pLine);</a>
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD_ADD"><a href="#NETMSG_RCON_CMD_ADD">NETMSG_RCON_CMD_ADD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>14</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_CMD_ADD_name"><a href="#NETMSG_RCON_CMD_ADD_name">Name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>TODO</td>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_CMD_ADD_help"><a href="#NETMSG_RCON_CMD_ADD_help">Help</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>TODO</td>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_CMD_ADD_params"><a href="#NETMSG_RCON_CMD_ADD_params">Params</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>TODO</td>
                </tr>
            </table>
            The server will send his list of rcon commands with parameters and help text
            to all authenticated clients. So after the client did authenticate the server starts sending
            NETMSG_RCON_CMD_ADD messages. There is a rate limit that avoid flooding the client
            with too much data. That is why when you authenticate to rcon and press tab to
            see the list of autocompletions they only show up after some time.
            The server uses the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L751-L758">
                SendRconCmdAdd()
            </a>
            method to send them which is called on tick if the ratelimit is not exceeded and the target client
            is authenticated.
            <pre class="code-snippet">
                <code>
    void CServer::SendRconCmdAdd(const IConsole::CCommandInfo *pCommandInfo, int ClientID)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD_ADD, true);
        Msg.AddString(pCommandInfo->m_pName, IConsole::TEMPCMD_NAME_LENGTH);
        Msg.AddString(pCommandInfo->m_pHelp, IConsole::TEMPCMD_HELP_LENGTH);
        Msg.AddString(pCommandInfo->m_pParams, IConsole::TEMPCMD_PARAMS_LENGTH);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            The client then receives them in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1291-L1298">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            where it stores them into the autocompletion list used by the remote console UI.
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD)
    {
        const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        const char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        const char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        if(Unpacker.Error() == 0)
            m_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD_REM"><a href="#NETMSG_RCON_CMD_REM">NETMSG_RCON_CMD_REM</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>15</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a> (mod_command)</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_CMD_REM_name"><a href="#NETMSG_RCON_CMD_REM_name">Name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>Name of command to be deleted</td>
                </tr>
            </table>
            This is the opposite as <a href="#NETMSG_RCON_CMD_ADD">NETMSG_RCON_CMD_ADD</a>.
            And is used by the server to remove commands from the clients known command list.
            While adding takes three parameters: name, parameters and help text. Removing
            only needs the name and the client will remove the whole commany entry that matches the name.
            This is only sent to moderators when an admin updates the list of commands
            accessible to moderators (using the rcon command
            <code>
                <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/shared/console.cpp#L824">
                    mod_command
                </a>
            </code>).
            The method sending this message is
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L760-L765">
                SendRconCmdRem()
            </a>
            <pre class="code-snippet">
                <code>
    void CServer::SendRconCmdRem(const IConsole::CCommandInfo *pCommandInfo, int ClientID)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD_REM, true);
        Msg.AddString(pCommandInfo->m_pName, 256);
        SendMsg(&Msg, MSGFLAG_VITAL, ClientID);
    }
                </code>
            </pre>
            If the client receives it it will remove the command with the given name
            from its list of known commands in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1299-L1304">
                CClient::ProcessServerPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM)
    {
        const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);
        if(Unpacker.Error() == 0)
            m_pConsole->DeregisterTemp(pName);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_CHALLANGE"><a href="#NETMSG_AUTH_CHALLANGE">NETMSG_AUTH_CHALLANGE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>16</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">Unused</td>
                </tr>
            </table>
            This message ID is unused <br>
            Note challenge is misspelled (here to optimize search results)
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_RESULT"><a href="#NETMSG_AUTH_RESULT">NETMSG_AUTH_RESULT</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>17</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">Unused</td>
                </tr>
            </table>
            This message ID is unused
        </p>
        <hr>
        <h2 id="NETMSG_READY"><a href="#NETMSG_READY">NETMSG_READY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>18</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> | <a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="#NETMSG_CON_READY">NETMSG_CON_READY</a> &amp; <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_MOTD">NETMSGTYPE_SV_MOTD</a> &amp; <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_SERVERSETTINGS">NETMSGTYPE_SV_SERVERSETTINGS</a>
                    </td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            This message ID is unused
            The client sends this to the server when it finished downloading the map
            or when it wants to skip the map download because it already has it in the downloadedmaps/ folder.
            The client uses the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L362-L366">
                CClient::SendReady()
            </a>
            method to send this message.
            <pre class="code-snippet">
                <code>
    void CClient::SendReady()
    {
        CMsgPacker Msg(NETMSG_READY, true);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            The server calls
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">
                SendConnectionReady(ClientID);
            </a>
            when it receives this message in the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L892-L908">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            method
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_READY)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && (m_aClients[ClientID].m_State == CClient::STATE_CONNECTING || m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player is ready. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, "server", aBuf);

            bool ConnectAsSpec = m_aClients[ClientID].m_State == CClient::STATE_CONNECTING_AS_SPEC;
            m_aClients[ClientID].m_State = CClient::STATE_READY;
            GameServer()->OnClientConnected(ClientID, ConnectAsSpec);
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">SendConnectionReady(ClientID);</a>
        }
    }
                </code>
            </pre>
            The
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L721-L725">
                SendConnectionReady(ClientID);
            </a>
            then sends the <a href="#NETMSG_CON_READY">NETMSG_CON_READY</a> as a response to the client.
        </p>
        <hr>
        <h2 id="NETMSG_ENTERGAME"><a href="#NETMSG_ENTERGAME">NETMSG_ENTERGAME</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>19</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="game_messages.html#NETMSGTYPE_SV_READYTOENTER">NETMSGTYPE_SV_READYTOENTER</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="game_messages.html#NETMSGTYPE_SV_COMMANDINFO">NETMSGTYPE_SV_COMMANDINFO</a> & <br>
                        <a href="#NETMSG_SERVERINFO">NETMSG_SERVERINFO</a> & <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_GAMEINFO">NETMSGTYPE_SV_GAMEINFO</a> & <br>
                        <a href="game_messages.html#NETMSGTYPE_SV_CLIENTINFO">NETMSGTYPE_SV_CLIENTINFO</a>
                    </td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            This message ID is unused
            Sent by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L356-L360">
                CClient::SendEnterGame()
            </a>
            <pre class="code-snippet">
                <code>
    void CClient::SendEnterGame()
    {
        CMsgPacker Msg(NETMSG_ENTERGAME, true);
        SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
    }
                </code>
            </pre>
            The server processes this message in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L909-L923">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_ENTERGAME)
    {
        if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))
        {
            char aAddrStr[NETADDR_MAXSTRSIZE];
            net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);

            char aBuf[256];
            str_format(aBuf, sizeof(aBuf), "player has entered the game. ClientID=%d addr=%s", ClientID, aAddrStr);
            Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, "server", aBuf);
            m_aClients[ClientID].m_State = CClient::STATE_INGAME;
            SendServerInfo(ClientID);
            GameServer()->OnClientEnter(ClientID);
        }
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_INPUT"><a href="#NETMSG_INPUT">NETMSG_INPUT</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>20</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Sent on changed user input</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_INPUTTIMING">NETMSG_INPUTTIMING</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_ack_game_tick"><a href="#NETMSG_INPUT_ack_game_tick">Ack Game Tick</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>TODO</td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_pred_tick"><a href="#NETMSG_INPUT_pred_tick">Prediction Tick</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>TODO</td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_size"><a href="#NETMSG_INPUT_size">Size</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        Size in bytes of the <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                        The client uses <code>sizeof(CNetObj_PlayerInput)</code> to calculate this size.
                        Since all fields of the struct are integers and integers are expected to be 4 bytes in C++
                        this size is 4 times bigger than the amount of integers that are being sent.
                        So until someone changes the layout of the <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a>
                        struct
                        <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/datasrc/network.py#L88-L104">here</a>
                        this value will always be <code>40</code> and the
                        <a href="#NETMSG_INPUT_data">data</a> field will be in the message
                        <code>10</code> times.
                    </td>
                </tr>
                <tr id="NETMSG_INPUT_data">
                    <td id="NETMSG_INPUT_data_m_Direction"><a href="#NETMSG_INPUT_data_m_Direction">[data] Direction</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_Direction">m_Direction</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct. <br>
                        Indicating the direction the tee wants to walk in.
                        <ul>
                            <li>-1 is left</li>
                            <li>1 is right</li>
                            <li>0 is stop</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_TargetX"><a href="#NETMSG_INPUT_data_m_TargetX">[data] TargetX</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_TargetX">m_TargetX</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct. <br>
                        X coordinate of the tees cursor. The coordinate is not absolute in the world  but relative to the tee.
                        The tee being the origin 0,0 and aiming left would be a negative x coordinate
                        and aiming right would be a positive x coordinate.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_TargetY"><a href="#NETMSG_INPUT_data_m_TargetY">[data] TargetY</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_TargetY">m_TargetY</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct. <br>
                        Y coordinate of the tees cursor. The coordinate is not absolute in the world but relative to the tee.
                        The tee being the origin 0,0 and aiming up would be a negative y coordinate
                        and aiming down would be a positive y coordinate.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_Jump"><a href="#NETMSG_INPUT_data_m_Jump">[data] Jump</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_Jump">m_Jump</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct. <br>
                        <ul>
                            <li>1 to jump while on ground</li>
                            <li>1 to double jump while in air</li>
                            <li>0 to stop holding jump</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_Fire"><a href="#NETMSG_INPUT_data_m_Fire">[data] Fire</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_Fire">m_Fire</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_Hook"><a href="#NETMSG_INPUT_data_m_Hook">[data] Hook</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_Hook">m_Hook</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                        <ul>
                            <li>1 to hook</li>
                            <li>0 to stop hooking</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_PlayerFlags"><a href="#NETMSG_INPUT_data_m_PlayerFlags">[data] PlayerFlags</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_PlayerFlags">m_PlayerFlags</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_WantedWeapon"><a href="#NETMSG_INPUT_data_m_WantedWeapon">[data] WantedWeapon</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_WantedWeapon">m_WantedWeapon</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_NextWeapon"><a href="#NETMSG_INPUT_data_m_NextWeapon">[data] NextWeapon</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_NextWeapon">m_NextWeapon</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_data_m_PrevWeapon"><a href="#NETMSG_INPUT_data_m_PrevWeapon">[data] PrevWeapon</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        <a href="#NETMSG_INPUT_m_PrevWeapon">m_PrevWeapon</a> of the
                        <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct.
                    </td>
                </tr>
                <tr>
                    <td id="NETMSG_INPUT_ping_correction"><a href="#NETMSG_INPUT_ping_correction">Ping Correction</a></td>
                    <td><a href="fundamentals.html#int_packing">Int</a></td>
                    <td>
                        TODO
                    </td>
                </tr>
            </table>
            Contains the input data from the client (hook/walk/fire/meta data and more).
            <h3 id="NETMSG_INPUT_when_is_sent"><a href="#NETMSG_INPUT_when_is_sent">When is NETMSG_INPUT sent</a></h3>
            The server assumes the input is held if no input message updates the state.
            So the official client also keeps the network bandwith minimal and does not
            resend this message if a key is held.
            <br>
            But if the client is active and in game it sends inputs at least in 10hz intervals
            <pre class="code-snippet">
                <code>
    // send at at least 10hz
    if(time_get() > s_LastSendTime + time_freq()/25)
        Send = true;
                </code>
            </pre>
            While the client is in the menu. Empty inputs will be send every second.
            <pre class="code-snippet">
                <code>
    // we freeze the input if chat or menu is activated
    if(m_pClient->m_pChat->IsActive() || m_pClient->m_pMenus->IsActive())
    {
        OnReset();

        mem_copy(pData, &m_InputData, sizeof(m_InputData));

        // send once a second just to be sure
        if(time_get() > s_LastSendTime + time_freq())
            Send = true;
    }
                </code>
            </pre>
            <h3 id="NETMSG_INPUT_what_is_sent"><a href="#NETMSG_INPUT_what_is_sent">What is sent in NETMSG_INPUT</a></h3>
            The message always contains 4 simple Integer fields:
            <a href="#NETMSG_INPUT_ack_game_tick">Ack Game Tick</a>,
            <a href="#NETMSG_INPUT_pred_tick">Prediction Tick</a>,
            <a href="#NETMSG_INPUT_size">Size</a>,
            <a href="#NETMSG_INPUT_ping_correction">Ping correction</a>.
            <br>
            And then there is <a href="#NETMSG_INPUT_size">Size / 4</a> amount of
            <a href="#NETMSG_INPUT_data">data</a> fields
            between the <a href="#NETMSG_INPUT_size">Size</a> field and the <a href="#NETMSG_INPUT_ping_correction">Ping correction</a>
            field. The official client is using a <a href="#CNetObj_PlayerInput">CNetObj_PlayerInput</a> struct to store
            the users key presses. All fields are integers so every field in the struct will become one
            <a href="#NETMSG_INPUT_data">data</a> field in the NETMSG_INPUT message.
            <pre id="CNetObj_PlayerInput" class="code-snippet">
                <code>
    struct <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/datasrc/network.py#L88-L104">CNetObj_PlayerInput</a>
    {
        int <a id="NETMSG_INPUT_m_Direction" href="#NETMSG_INPUT_m_Direction">m_Direction</a>;
        int <a id="NETMSG_INPUT_m_TargetX" href="#NETMSG_INPUT_m_TargetX">m_TargetX</a>;
        int <a id="NETMSG_INPUT_m_TargetY" href="#NETMSG_INPUT_m_TargetY">m_TargetY</a>;
        int <a id="NETMSG_INPUT_m_Jump" href="#NETMSG_INPUT_m_Jump">m_Jump</a>;
        int <a id="NETMSG_INPUT_m_Fire" href="#NETMSG_INPUT_m_Fire">m_Fire</a>;
        int <a id="NETMSG_INPUT_m_Hook" href="#NETMSG_INPUT_m_Hook">m_Hook</a>;
        int <a id="NETMSG_INPUT_m_PlayerFlags" href="#NETMSG_INPUT_m_PlayerFlags">m_PlayerFlags</a>;
        int <a id="NETMSG_INPUT_m_WantedWeapon" href="#NETMSG_INPUT_m_WantedWeapon">m_WantedWeapon</a>;
        int <a id="NETMSG_INPUT_m_NextWeapon" href="#NETMSG_INPUT_m_NextWeapon">m_NextWeapon</a>;
        int <a id="NETMSG_INPUT_m_PrevWeapon" href="#NETMSG_INPUT_m_PrevWeapon">m_PrevWeapon</a>;
    };
                </code>
            </pre>
            <h3 id="NETMSG_INPUT_what_is_reply"><a href="#NETMSG_INPUT_what_is_reply">What does the server reply to NETMSG_INPUT</a></h3>
            The server unpacks this message in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/server/server.cpp#L924-L951">
                CServer::ProcessClientPacket(CNetChunk *pPacket)
            </a>
            and replys with <a href="#NETMSG_INPUTTIMING">NETMSG_INPUTTIMING</a>
            <pre class="code-snippet">
                <code>
    else if(Msg == NETMSG_INPUT)
    {
        CClient::CInput *pInput;
        int64 TagTime;
        int64 Now = time_get();

        m_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();
        int IntendedTick = Unpacker.GetInt();
        int Size = Unpacker.GetInt();

        // check for errors
        if(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)
            return;

        if(m_aClients[ClientID].m_LastAckedSnapshot > 0)
            m_aClients[ClientID].m_SnapRate = CClient::SNAPRATE_FULL;

        // add message to report the input timing
        // skip packets that are old
        if(IntendedTick > m_aClients[ClientID].m_LastInputTick)
        {
            int TimeLeft = ((TickStartTime(IntendedTick)-Now)*1000) / time_freq();

            CMsgPacker Msg(NETMSG_INPUTTIMING, true);
            Msg.AddInt(IntendedTick);
            Msg.AddInt(TimeLeft);
            SendMsg(&Msg, 0, ClientID);
        }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_CMD"><a href="#NETMSG_RCON_CMD">NETMSG_RCON_CMD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>21</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Sent when the client submits a rcon command</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        [ <a href="#NETMSG_RCON_LINE">NETMSG_RCON_LINE</a> ] | <br>
                        [ <a href="#NETMSG_RCON_AUTH_OFF">NETMSG_RCON_AUTH_OFF</a> <code>logout</code> ] | <br>
                        [ <a href="#NETMSG_SERVERINFO">NETMSG_SERVERINFO</a> <code>sv_name</code>, <code>password</code>, <code>sv_max_clients</code> ] | <br>
                        [
                            <a href="game_messages.html#NETMSGTYPE_SV_SERVERSETTINGS">NETMSGTYPE_SV_SERVERSETTINGS</a>
                            <code>sv_vote_kick</code> (and <a href="game_messages.html#NETMSGTYPE_SV_SERVERSETTINGS">more</a>)
                        ]
                    </td>
                </tr>
            </table>
            <br>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_CMD_command"><a href="#NETMSG_RCON_CMD_command">Command</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>The rcon command like for example <code>status</code> or <code>shutdown</code></td>
                </tr>
            </table>
            <br>
            Sent by the client using the
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L378-L383">
                CClient::Rcon(const char *pCmd)
            </a>
            method.
            <pre class="code-snippet">
                <code>
    void CClient::Rcon(const char *pCmd)
    {
        CMsgPacker Msg(NETMSG_RCON_CMD, true);
        Msg.AddString(pCmd, 256);
        SendMsg(&Msg, MSGFLAG_VITAL);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_RCON_AUTH"><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>22</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Sent on user input (password attempt in console)</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th>
                    <td>
                        <a href="#NETMSG_RCON_AUTH_ON">NETMSG_RCON_AUTH_ON</a> | <br>
                        <a href="#NETMSG_RCON_LINE">NETMSG_RCON_LINE</a> (wrong password/no password set) | <br>
                        <a href="ctrl_messages.html#NET_CTRLMSG_CLOSE">NET_CTRLMSG_CLOSE</a> (Too many remote console authentication tries)
                    </td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_RCON_AUTH_password"><a href="#NETMSG_RCON_AUTH_password">Password</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>
                        The password has to match either
                        <code>sv_rcon_password</code>
                        or
                        <code>sv_rcon_mod_password</code>
                        to successfully authenticate. <br>
                        If both are set to an empty string <code>""</code>
                        users can not authenticate.
                    </td>
                </tr>
            </table>
            <h3>No encryption</h3>
            Since the field type is a normal <a href="fundamentals.html#string_packing">String</a>
            the password is sent as plaintext. Which shows up as a fully readable string
            when looking at the network traffic.
            <h3>Weak bruteforce protection</h3>
            Clients can send this packet up to <code>sv_rcon_max_tries</code> (default 3) times.
            But it is tracked per client not per ip. So one user with one ip
            can attempt (<code>sv_max_clients_per_ip</code> x <code>sv_rcon_max_tries</code>)
            passwords without reconnecting. Which is <code>4 x 3 = 12</code> by default.
            Reconnecting then resets the whole client data including the rcon attempt counter
            so you get <code>sv_rcon_max_tries</code> again. Note that reconnecting takes some
            time and the server kicks ips that reconnect too fast for 1 minute.
            <br>
            <br>
            Sent by the client in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L368-L376">
                CClient::RconAuth()
            </a>
            <pre class="code-snippet">
                <code>
    void CClient::RconAuth(const char *pName, const char *pPassword)
    {
        if(RconAuthed())
            return;

        CMsgPacker Msg(NETMSG_RCON_AUTH, true);
        Msg.AddString(pPassword, 32);
        SendMsg(&Msg, MSGFLAG_VITAL);
    }
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_REQUEST_MAP_DATA"><a href="#NETMSG_REQUEST_MAP_DATA">NETMSG_REQUEST_MAP_DATA</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>23</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th>
                    <td>
                        <a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> (download start) | <br>
                        <a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a> (continue download)
                    </td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            After the server did send <code>sv_map_download_speed</code> (default 8)
            <a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a> chunks the client has to request
            more by sending this message.
            <br>
            <br>
            Sent to kickstart the download on <a href="#NETMSG_MAP_CHANGE">NETMSG_MAP_CHANGE</a> in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1214-L1216">
                CClient::ProcessServerPacket()
            </a>
            <pre class="code-snippet">
                <code>
    // request first chunk package of map data
    CMsgPacker Msg(NETMSG_REQUEST_MAP_DATA, true);
    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
                </code>
            </pre>
            And also in
            <a href="https://github.com/teeworlds/teeworlds/blob/26d24ec061d44e6084b2d77a9b8a0a48e354eba6/src/engine/client/client.cpp#L1263-L1265">
                CClient::ProcessServerPacket()
            </a> on <a href="#NETMSG_MAP_DATA">NETMSG_MAP_DATA</a> to keep the download going
            <pre class="code-snippet">
                <code>
    // request next chunk package of map data
    CMsgPacker Msg(NETMSG_REQUEST_MAP_DATA, true);
    SendMsg(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);
                </code>
            </pre>
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_START"><a href="#NETMSG_AUTH_START">NETMSG_AUTH_START</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>24</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            This message ID is unused
        </p>
        <hr>
        <h2 id="NETMSG_AUTH_RESPONSE"><a href="#NETMSG_AUTH_RESPONSE">NETMSG_AUTH_RESPONSE</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>25</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            This message ID is unused
        </p>
        <hr>
        <h2 id="NETMSG_PING"><a href="#NETMSG_PING">NETMSG_PING</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>26</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Triggerd client side by the <code>ping</code> console command</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td><a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a></td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            Sent by the client to the server to measure the time until the
            <a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a>.
            One of the most optional messages in the protocol only used by clients that are
            interested in the delay between server and client.
        </p>
        <hr>
        <h2 id="NETMSG_PING_REPLY"><a href="#NETMSG_PING_REPLY">NETMSG_PING_REPLY</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Client <br> Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>27</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_PING">NETMSG_PING</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            Even though the client technically replys to <a href="#NETMSG_PING">NETMSG_PING</a>
            with this message it practically never does since the server never sends <a href="#NETMSG_PING">NETMSG_PING</a>.
        </p>
        <hr>
        <h2 id="NETMSG_ERROR"><a href="#NETMSG_ERROR">NETMSG_ERROR</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>28</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>Unused</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td colspan="3">None</td>
                </tr>
            </table>
            This message ID is unused
        </p>
        <hr>
        <h2 id="NETMSG_MAPLIST_ENTRY_ADD"><a href="#NETMSG_MAPLIST_ENTRY_ADD">NETMSG_MAPLIST_ENTRY_ADD</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>Server</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>29</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td><a href="#NETMSG_RCON_AUTH">NETMSG_RCON_AUTH</a></td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_MAPLIST_ENTRY_ADD_map_name"><a href="#NETMSG_MAPLIST_ENTRY_ADD_map_name">Map name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>Name of the map that should be added to the clients autocompletion list</td>
                </tr>
            </table>
            <strong>Note:</strong>
            the msg id is planned to be changed in 0.8
            <br>
            <br>
            Similar to the rcon command autocompletion in the clients remote console (<a href="#NETMSG_RCON_CMD_ADD">NETMSG_RCON_CMD_ADD</a>).
            This sends autocompletion for the argument of the rcon commands <code>sv_map</code> and <code>change_map</code>.
            The server sends every map entry from its map folder to the clients that authenticated in the rcon console.
            Admininistrators and moderators can then type <code>sv_map</code> into the remote console
            and see/autocomplete the list of possible maps.
        </p>
        <hr>
        <h2 id="NETMSG_MAPLIST_ENTRY_REM"><a href="#NETMSG_MAPLIST_ENTRY_REM">NETMSG_MAPLIST_ENTRY_REM</a></h2>
        <p>
            <table>
                <tr>
                    <th><strong>Sender:</strong></th><td>[Server]</td>
                </tr>
                <tr>
                    <th><strong>Recipient:</strong></th><td>Client</td>
                </tr>
                <tr>
                    <th><strong>Message ID:</strong></th><td>30</td>
                </tr>
                <tr>
                    <th><strong>Response to:</strong></th><td>Unused</td>
                </tr>
                <tr>
                    <th><strong>Expected response:</strong></th><td>None</td>
                </tr>
            </table>
            <table>
                <tr>
                    <th>Argument name</th>
                    <th>Type</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td id="NETMSG_MAPLIST_ENTRY_REM_map_name"><a href="#NETMSG_MAPLIST_ENTRY_REM_map_name">Map name</a></td>
                    <td><a href="fundamentals.html#string_packing">String</a></td>
                    <td>Name of the map that should be removed from the clients autocompletion list</td>
                </tr>
            </table>
            <strong>Note:</strong>
            the msg id is planned to be changed in 0.8
            <br>
            <br>
            Counter part to <a href="#NETMSG_MAPLIST_ENTRY_ADD">NETMSG_MAPLIST_ENTRY_ADD</a>.
            Removing map names from the autocompletion list.
            There is code in the server that can send this message and there is code in the client
            that removes the entry. But it is never run. So this message is technically unused (for now).
        </p>
    </div> <!-- content -->
    <footer>
        <hr>
        <div class="footer">
            <!-- Icon-link to source code on GitHub -->
            <a class="github" href="https://github.com/ChillerDragon/teeworlds-protocol" target="_blank" rel="noopener" aria-label="Source code">
                <!-- icon: https://materialdesignicons.com/icon/github -->
                <svg viewBox="0 0 24 24" class="github">
                    <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" />
                </svg>
            </a>
            <span>
                ChillerDragon - 2023
            </span>
        </div>
    </footer>
</body>
